{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is CocosAI","text":"<p>CocosAI (Confidential Computing System for AI) is a SW system for enabling confidential and privacy-preserving AI/ML, i.e. execution of model training and algorithm inference on confidential data sets. Privacy-preservation is considered a \u201choly grail\u201d of AI. It opens many possibilities, among which is a collaborative, trustworthy AI.</p> <p>CocosAI leverages Confidential Computing, a novel paradigm based on specialized HW CPU extensions for producting secure encrypted enclaves in memory (Trusted Execution Enviroments, or TEEs), thus isloalting confidential data and programs from the rest of the SW running on the hos</p> <p>The final product enables data scientists to train AI and ML models on confidential data that is never revealed, and can be used for Secure Multi-Party Computation (SMPC). AI/ML on combined data sets that come from different sources will unlock huge value.</p> <p></p>"},{"location":"#features","title":"Features","text":"<p>CoCoS.ai is enabling the following features:</p> <ul> <li>TEE enablement, deployment and monitoring</li> <li>In-enclave agent, netowrking controller and other system software</li> <li>Encrypted asynchronous data transfer and result delivery</li> <li>API for programmable platform manipulation</li> <li>HW and SW supported attestation with verification tools</li> <li>CLI for system interaction</li> </ul>"},{"location":"#license","title":"License","text":"<p>CocosAI is published under liberal Apache-2.0 open-source license.</p>"},{"location":"#github","title":"GitHub","text":"<p>CcosAI can be downlaoded from its GitHub repository</p>"},{"location":"agent/","title":"Agent","text":"<p>The agent is responsible for the life cycle of the computation, i.e., running the computation and sending events about the status of the computation within the TEE. The agent is found inside the VM (TEE), and each computation within the TEE has its own agent. When a computation run request is sent from from the manager, manager creates a VM where the agent is found and sends the computation manifest to the agent. </p> <p>The picture below shows where the Agent runs in the Cocos system, helping us better understand its role.</p> <p></p>"},{"location":"agent/#statemachine","title":"StateMachine","text":"<ul> <li>Orchestrates the overall flow of the computation.</li> <li>Transitions between states based on received events.</li> <li>Defines valid state transitions and associated functions.</li> </ul>"},{"location":"agent/#states","title":"States","text":"<ul> <li><code>idle</code>: Initial state, waiting for the computation to start.</li> <li><code>receivingManifest</code>: Receives the initial computation manifest.</li> <li><code>receivingAlgorithm</code>: Receives the algorithm for the computation.</li> <li><code>receivingData</code>: Receives dataset data for the computation.</li> <li><code>running</code>: Executes the computation using received algorithms and data.</li> <li><code>resultsReady</code>: Computation has finished, results are available.</li> <li><code>complete</code>: All results have been consumed, computation lifecycle ends.</li> </ul>"},{"location":"agent/#events","title":"Events","text":"<ul> <li><code>start</code>: Triggers the computation startup process.</li> <li><code>manifestReceived</code>: Indicates computation manifest has been received.</li> <li><code>algorithmReceived</code>: Indicates the algorithm has been received.</li> <li><code>dataReceived</code>: Indicates all dataset data has been received.</li> <li><code>runComplete</code>: Signals the completion of the computation execution.</li> <li><code>resultsConsumed</code>: Indicates all consumers have retrieved the results.</li> </ul>"},{"location":"agent/#agent-events","title":"Agent Events","text":"<p>As the computation in the agent undergoes different operations, it sends events to the manager so that the user can monitor the computation from either the UI or other client. Events sent to the manager based on the agent state as defined by the statemachine.</p>"},{"location":"agent/#vsock-connection-between-agent-manager","title":"Vsock Connection Between Agent &amp; Manager","text":"<p>Agent sends agent events and logs to the manager via vsock. The manager listens to the vsock and forwards the events via gRPC. The agent events and logs are used to show the status of the computation inside the TEE so that a user can be aware of what is happening inside the TEE.</p>"},{"location":"agent/#attestation","title":"Attestation","text":"<p>The Agent can fetch the attestation report from the host using the AMD SEV guest driver. The attestation report proves that the Agent is running inside the secure virtual machine (SVM) and that the SVM is running the expected code on the expected hardware and is configured correctly.</p>"},{"location":"agent/#algorithm-and-dataset-validation","title":"Algorithm and dataset validation","text":"<p>Before execution, algorithms and datasets are validated against the computation manifest to ensure integrity and compatibility. This includes the sha3 256 hash of the dataset and algorithm, which are validated against the value set in the manifest. The algorithm and dataset provider ID are also validated against the manifest during the uploading of the dataset and algorithm.</p>"},{"location":"agent/#supported-algorithm-types","title":"Supported Algorithm types","text":"<p>There are two supported algorithm types, binaries and python files. The default algorithm type is binaries, which is uploaded to agent using CLI. To upload a python file, the python file should be accompanied by the requirements file which will be used to provision the VM with all required libraries prior to algorithm execution. Instructions on how to provide a python file are provided in  CLI.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>CocosAI system is running on the host, and it's main goal is to enable:</p> <ul> <li>Programatic creation of enclaves (TEEs)</li> <li>Gest OS and system enviroment withn the enclave VMs</li> <li>Monitoring of enclaves</li> <li>In-enclave SW manager agent</li> <li>Ectyped data trensfer into the enclave and computation execution</li> <li>Result retrieval via encrypted channel to an authorized party</li> <li>Providing of HW measurement and attestation report</li> <li>Enablement of vTPM and DICE integrity checks (root chain of trust) in order to ensure secure boot of the TEEs</li> </ul> <p>These features are implemented by several independed components of CocosAI system:</p> <ol> <li>Manager</li> <li>Agent</li> <li>EOS (Enclave Operating System)</li> <li>CLI</li> </ol> <p></p> <p>N.B. CocosAI open-source project does not provide Computation Management service. It is usually a cloud component, used to define a Computation (i.e. define computation metadata, like participant list, algorithm and data providers, result recipients, etc...). Ultraviolet provide commercial product Prism, a multi-party computation platform, that implements multi-tenant and scalable Computation Management service, running in the cloud or on premise, and capable to connect and control CocosAI system running on the TEE host.</p>"},{"location":"architecture/#manager","title":"Manager","text":"<p>Manager is a gRPC client that listens to requests sent through gRPC and sends them to Agent via vsock. Manager creates a secure enclave and loads the computation where the agent resides. The connection between Manager and Agent is through vsock, through which channel agent sends events periodically to manager, who forwards these via gRPC.</p>"},{"location":"architecture/#agent","title":"Agent","text":"<p>Agent defines firmware which goes into the TEE and is used to control and monitor computation within TEE and enable secure and encrypted communication with outside world (in order to fetch the data and provide the result of the computation). The Agent contains a gRPC server that listens for requests from gRPC clients. Communication between the Manager and Agent is done via vsock. The Agent sends events to the Manager via vsock, which then forwards these via gRPC. Agent contains a gRPC server that exposes useful functions that can be accessed by other gRPC clients such as the CLI.</p>"},{"location":"architecture/#eos","title":"EOS","text":"<p>EOS, or Enclave Operating System, is ...</p>"},{"location":"architecture/#cli","title":"CLI","text":"<p>CoCoS CLI is used to access the agent within the secure enclave. CLI communicates to agent using gRPC, with funcitons such as algo to provide the algorithm to be run, data to provide the data to be used in the computation, and run to start the computation. It also has functions to fetch and validate the attestation report of the enclave.</p> <p>For more information on CLI, please refer to CLI docs.</p>"},{"location":"attestation/","title":"Attestation","text":"<p>Remote attestation is a process in which one side (the attester) collects information about itself and sends that information to the client (or the relying party) so that the relying party can verify the attester. The successful verification proves to the relying party that the secure virtual machine (SVM) runs the expected code on the expected hardware and is configured correctly. If the attester is deemed trustworthy, the relying party will send confidential code/data to the attester. This information implies that a secure channel needs to be formed between the attester and the relaying party. The secure channel is created using attested TLS.</p> <p>Cocos has two software components that represent the attester and the relying party:</p> <ol> <li>The Agent - software application that is running inside the HAL. It is responsible for fetching the attestation report and running the computation.</li> <li>Cocos CLI - a command-line application running on the machines of each Secure Multiparty Computation (SMPC) member. It verifies the attestation report and sends confidential code/data to the Agent.</li> </ol>"},{"location":"attestation/#what-are-the-parts-of-the-attestation-report","title":"What are the parts of the attestation report?","text":"<p>One of the essential parts of the attestation report is the measurement. The measurement represents the hash of the entire SVM or the hash of the HAL. This way, the measurement provides a way for the client to verify the contents of the entire SVM. </p> <p>Along with the measurement, the attestation report provides additional information about the booted SVM and underlying hardware, such as the policy with which the SVM was booted and the SNP firmware's trusted computing base (TCB) version.</p> <p>The AMD SEV-SNP attestation report can also be filled with arbitrary data. The width of this data field is 512 bits, and it is called report data. The report data content is provided by the Agent to the ASP every time the attestation report is generated.</p> <p>The last part of the report is the signature. The hardware signs the AMD SEV-SNP attestation report using the Versioned Chip Endorsement Key (VCEK). VCEK is derived from chip unique secrets and the current SNP firmware TCB. The signature is verified by obtaining the certificate for the VCEK from the AMD Key Distribution System (KDS). By verifying the signature, the relying party can be sure that the SVM is running on genuine AMD hardware and that the AMD Secure Processor (ASP) generated the attestation report.</p>"},{"location":"attestation/#how-is-the-attestation-report-fetched","title":"How is the attestation report fetched?","text":"<p>The Agent is responsible for fetching the attestation report from the SVM. This procedure is safe because the Kernel and the ASP can exchange encrypted messages that can only be decrypted by the Kernel and the ASP. The keys used for the encryption/decryption are inserted by the ASP into the memory of the SVM during boot, thus ensuring that only the ASP and the SVM have the keys for safe communication.</p>"},{"location":"attestation/#attested-tls","title":"Attested TLS","text":"<p>For the relying party to send confidential data or code to the Agent, a secure channel must be established between them. This is done using attested TLS, which is a TLS connection where the server's certificate is extended with the attestation report. The SVM is the server in Cocos. The Agent generates a self-signed x.509 certificate extended with the attestation report. When fetching the attestation report, the Agent inserts the hash of the public key into it using the field report data. The whole process can be seen in the below picture. The green color represents the trusted part of the system, while the red is untrusted.</p> <p></p> <p>The relying party uses the Cocos CLI to verify the self-signed certificate and the attestation report that is part of it. Successful verification proves to the relying party that the certificate is generated inside the SVM because the certificate's public key is part of the attestation report.</p>"},{"location":"cli/","title":"Agent CLI","text":"<p>The CLI allows you to perform various tasks related to the computation and management of algorithms, datasets and TEE. The CLI is a gRPC client for the agent service. To communicate with agent, digital signatures are required for auth against the roles such dataset provider.</p>"},{"location":"cli/#build","title":"Build","text":"<p>To build the CLI, follow these steps:</p> <ol> <li>Clone the repository: <code>go get github.com/ultravioletrs/cocos</code>.</li> <li>Navigate to the project root: <code>cd cocos</code>.</li> <li>Build the CLI binary: <code>make cli</code>.</li> </ol>"},{"location":"cli/#usage","title":"Usage","text":""},{"location":"cli/#generate-keys","title":"Generate Keys","text":"<p>To generate a public &amp; private key pair, run the following command:</p> <pre><code>./build/cocos-cli keys\n</code></pre> <p>This will generate a key pair of type rsa. Different key types can be generated using the <code>-k</code> flag. Currently supported types on cocos are rsa, ecdsa and ed25519.</p> <pre><code>./build/cocos-cli keys -k ecdsa\n</code></pre>"},{"location":"cli/#set-agent-url","title":"Set Agent URL","text":"<p>For commands involving sending data to agent (data and algo upload, result fetching), the agent url is required since cli uses this to connect to the specified agent.</p> <pre><code>export AGENT_GRPC_URL=&lt;agent_host:agent_port&gt;\n</code></pre> <p>Agent port is found from the manager logs after the TEE has been provisioned and agent inserted.</p>"},{"location":"cli/#upload-algorithm","title":"Upload Algorithm","text":"<p>To upload an algorithm, use the following command:</p> <pre><code>./build/cocos-cli algo /path/to/algorithm /path/to/private/key\n</code></pre> <p>Currently, support is provided for two types of algorithms: executable binaries and python files. The above command expects an algorithm in the binary format which will be executed inside agent. For python files, the algo file is required, along with the requirements file and the python runtime. To run a python file, use the following command:</p> <pre><code>./build/cocos-cli algo /path/to/algorithm /path/to/private/key --algorithm python --requirements /path/to/requirements.txt --python-runtime python\n</code></pre> <p>The agent grpc url is required for this operation, this will be available once the TEE has been provisioned and agent is running.</p> <p>Supported flags:</p> <pre><code>  -a, --algorithm string        Algorithm type to run (default \"bin\")\n  -h, --help                    help for algo\n      --python-runtime string   Python runtime to use (default \"python3\")\n  -r, --requirements string     Python requirements file\n</code></pre>"},{"location":"cli/#upload-dataset","title":"Upload Dataset","text":"<p>To upload a dataset, use the following command:</p> <pre><code>./build/cocos-cli data /path/to/dataset.csv /path/to/private/key\n</code></pre> <p>The agent grpc url is required for this operation, this will be available once the TEE has been provisioned and agent is running.</p>"},{"location":"cli/#retrieve-result","title":"Retrieve Result","text":"<p>To retrieve the computation result, use the following command:</p> <pre><code>./build/cocos-cli result /path/to/private/key\n</code></pre> <p>If the result is available and agent is ready to receive the results, the result will be extracted and written to the current directory as <code>result.bin</code>.</p> <p>The agent grpc url is required for this operation, this will be available once the TEE has been provisioned and agent is running.</p>"},{"location":"cli/#fetch-and-validate-attestation-report","title":"Fetch and Validate Attestation Report","text":"<p>To fetch or validate the attestation report, use the following commands.</p> <p>To fetch attestation report:</p> <pre><code>./build/cocos-cli attestation get &lt;report_data&gt;\n</code></pre> <p>To validate attestation report</p> <pre><code>./build/cocos-cli attestation validate &lt;attestation_report_file_path&gt; --report_data &lt;report_data&gt;\n</code></pre> <p>To validate the report data, the report data flag is compulsory.</p> <p>Optional Flags:</p> <pre><code>      --CA_bundles stringArray                  PEM format CA bundles for the AMD product. Combined with contents of cabundle_paths.\n      --CA_bundles_paths stringArray            Paths to CA bundles for the AMD product. Must be in PEM format, ASK, then ARK certificates. If unset, uses embedded root certificates.\n      --check_crl                               Download and check the CRL for revoked certificates.\n      --chip_id bytesHex                        The expected MEASUREMENT field as a hex string. Must encode 48 bytes. Unchecked if unset.\n      --config string                           Serialized json check.Config protobuf. This will overwrite individual flags. Unmarshalled as json.                                      \n      --family_id bytesHex                      The expected FAMILY_ID field as a hex string. Must encode 16 bytes. Unchecked if unset.\n      --guest_policy uint                       The most acceptable guest SnpPolicy. (default 196608)\n  -h, --help                                    help for validate\n      --host_data bytesHex                      The expected HOST_DATA field as a hex string. Must encode 32 bytes. Unchecked if unset.\n      --image_id bytesHex                       The expected IMAGE_ID field as a hex string. Must encode 16 bytes. Unchecked if unset.\n      --max_retry_delay duration                Maximum Duration to wait between HTTP request retries. (default 30s)\n      --measurement bytesHex                    The expected MEASUREMENT field as a hex string. Must encode 48 bytes. Unchecked if unset.\n      --minimum_build uint32                    The 8-bit minimum build number for AMD-SP firmware\n      --minimum_guest_svn uint32                The most acceptable GUEST_SVN.\n      --minimum_lauch_tcb uint                  The minimum acceptable value for LAUNCH_TCB.\n      --minimum_tcb uint                        The minimum acceptable value for CURRENT_TCB, COMMITTED_TCB, and REPORTED_TCB.\n      --minimum_version string                  Minimum AMD-SP firmware API version (major.minor). Each number must be 8-bit non-negative. (default \"0.0\")\n      --platform_info string                    The maximum acceptable PLATFORM_INFO field bit-wise. May be empty or a 64-bit unsigned integer\n      --product string                          The AMD product name for the chip that generated the attestation report.\n      --report_data bytesHex                    The expected REPORT_DATA field as a hex string. Must encode 64 bytes. Must be set.\n      --report_id bytesHex                      The expected REPORT_ID field as a hex string. Must encode 32 bytes. Unchecked if unset.\n      --report_id_ma bytesHex                   The expected REPORT_ID_MA field as a hex string. Must encode 32 bytes. Unchecked if unset.\n      --require_author_key                      Require that AUTHOR_KEY_EN is 1.\n      --require_id_block                        Require that the VM was launch with an ID_BLOCK signed by a trusted id key or author key\n      --stepping string                         The machine stepping for the chip that generated the attestation report. Default unchecked.\n      --timeout duration                        Duration to continue to retry failed HTTP requests. (default 2m0s)\n      --trusted_author_key_hashes stringArray   Hex-encoded SHA-384 hash values of trusted author keys in AMD public key format\n      --trusted_author_keys stringArray         Paths to x.509 certificates of trusted author keys\n      --trusted_id_key_hashes stringArray       Hex-encoded SHA-384 hash values of trusted identity keys in AMD public key format\n      --trusted_id_keys stringArray             Paths to x.509 certificates of trusted author keys\n</code></pre>"},{"location":"cli/#file-hash","title":"File Hash","text":"<p>To run a computation, the hash of the files to be uploaded is provided along with the computation manifest. The file hash can be generated by cli, and this can be done using the following command:</p> <pre><code>./build/cocos-cli file-hash /path/to/file\n</code></pre>"},{"location":"cli/#backend-info","title":"Backend Info","text":"<p>To change or add information about the backend, the following commands can be used.</p> <p>To add measurement data:</p> <pre><code>./build/cocos-cli backend measurement &lt;measurement&gt; &lt;backend_info.json&gt;\n</code></pre> <p>To add host data:</p> <pre><code>./build/cocos-cli attestation hostdata &lt;host-data&gt; &lt;backend_info.json&gt;\n</code></pre> <p>The backend information is obtained from the backend that has SEV. Check backend info readme for information on how to run the script to generate backend info.</p>"},{"location":"cli/#fetch-amd-sev-snps-ca-bundle-ask-and-ark","title":"Fetch AMD SEV-SNPs CA Bundle (ASK and ARK)","text":"<p>To fetch the CA bundle for SEV-SNP, use the following commands:</p> <pre><code>./build/cocos-cli ca-bundle &lt;path_to_platform_info.json&gt;\n</code></pre>"},{"location":"cli/#installation","title":"Installation","text":"<p>To install the CLI locally, i.e. for the current user:</p> <p>Run <code>cp ./build/cocos-cli $GOBIN</code>.</p>"},{"location":"cli/#notes","title":"Notes","text":"<ul> <li>The CLI supports various configuration flags and options</li> <li>Use the <code>--help</code> flag with any command to see additionalinformation</li> <li>The CLI uses gRPC for communication with the Agent service</li> <li>All traffic between CLI and the TEE is encrypted via mutual TLS</li> </ul>"},{"location":"computation/","title":"Computation","text":"<p>Computation in CocosAI is any execution of a program (Algorithm) or an data set (Data), that can be one data file, or a lot of files comping from different parties.</p> <p>Computations are multi-party, meaning that program and data providers can be different parties that do not want to expose their intellectual property to other parties participating in the computation.</p> <p><code>Computation</code> is a structure that holds all the necessary information needed to execute the computation securely (list of participants, execution backend - i.e. where computation will be executed, role of each participant, cryptographic certificates, etc...).</p>"},{"location":"computation/#computation-roles","title":"Computation Roles","text":"<p>Computation is multi-party, i.e. has multiple participants. Each of the users that participate in the computation can have one of the follwoing roles:</p> <ol> <li>Computation Owner - user that created the <code>Computation</code> and that defines who will participate in it and with wich role (by inviting other users to the Computation)</li> <li>Algorithm Provider - user that will provide th actual program to be executed</li> <li>Data Provider - user that will provide a data on which algorithm will be executed, i.e. data which algorithm will process</li> <li>Result Recipient - user that will recieve result after the processing</li> </ol> <p>One user can have several roles - for example, Algorithm Provider can also be a Result Recipient.</p>"},{"location":"computation/#computation-manifest","title":"Computation Manifest","text":"<p>Computation Manifest represent that Computation description and is sent upon <code>run</code> command to the Manager as a JSON.</p> <p>Manager fetches the Computation Manifest and sends it into the TEE to Agent, via vsock.</p> <p>The first thing that Agent does upon boot, is that it fetches the Computation Manifest and reads it. For this Manifest, Agent understands who are the participants in the computation adn with wich role, i.e. from whom it can accept the connections and what data they will send. Agent also learns from the Manifest what algorithm is used and how many datasets will be provided. This way it knows when it received all necessary files to start the execution. Finally, Agent learns from the Manifest to whom it needs to send the Result of the computation.</p>"},{"location":"developer-guide/","title":"Developer Guide","text":""},{"location":"developer-guide/#getting-cocos","title":"Getting CoCos","text":"<p>CoCos is found on the CoCos repository. You should fork the repository in order to make changes to the repository. After forking the repository, you can clone it as follows:</p> <pre><code>git clone &lt;forked repository&gt; $SOMEPATH/cocos\ncd $SOMEPATH/cocos\n</code></pre>"},{"location":"developer-guide/#building","title":"Building","text":""},{"location":"developer-guide/#prerequisites","title":"Prerequisites","text":"<ul> <li>Protocol Buffers</li> <li>Golang</li> </ul>"},{"location":"developer-guide/#build-all-services","title":"Build All Services","text":"<p>Use the GNU Make tool to build all CoCos services: <code>make</code> Build artifacts will be put in the build directory.</p>"},{"location":"developer-guide/#building-hal","title":"Building HAL","text":"<p>To build the custom linux image that will host agent, run:</p> <pre><code>git clone git@github.com:buildroot/buildroot.git\ncd buildroot\nmake BR2_EXTERNAL=../cocos/hal/linux cocos_defconfig\nmake menuconfig #optional for additional configuration\nmake\n</code></pre>"},{"location":"developer-guide/#testing-hal-image","title":"Testing HAL image","text":""},{"location":"developer-guide/#enable-v-sock","title":"Enable V-Sock","text":"<p>The necessary kernel modules must be loaded on the hypervisor.</p> <pre><code>sudo modprobe vhost_vsock\nls -l /dev/vhost-vsock\n# crw-rw-rw- 1 root kvm 10, 241 Jan 16 12:05 /dev/vhost-vsock\nls -l /dev/vsock\n# crw-rw-rw- 1 root root 10, 121 Jan 16 12:05 /dev/vsock\n</code></pre>"},{"location":"developer-guide/#launch-the-vm","title":"Launch the VM","text":"<p>To launch the virtual machine containing agent for testing purposes, run:</p> <pre><code>sudo find / -name OVMF_CODE.fd\n# =&gt; /usr/share/OVMF/OVMF_CODE.fd\nOVMF_CODE=/usr/share/OVMF/OVMF_CODE.fd\n\nsudo find / -name OVMF_VARS.fd\n# =&gt; /usr/share/OVMF/OVMF_VARS.fd\nOVMF_VARS=/usr/share/OVMF/OVMF_VARS.fd\n\nKERNEL=\"buildroot/output/images/bzImage\"\nINITRD=\"buildroot/output/images/rootfs.cpio.gz\"\n\nqemu-system-x86_64 \\\n    -enable-kvm \\\n    -cpu EPYC-v4 \\\n    -machine q35 \\\n    -smp 4 \\\n    -m 2048M,slots=5,maxmem=10240M \\\n    -no-reboot \\\n    -drive if=pflash,format=raw,unit=0,file=$OVMF_CODE,readonly=on \\\n    -netdev user,id=vmnic,hostfwd=tcp::7020-:7002 \\\n    -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,romfile= \\\n    -device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=3 -vnc :0 \\\n    -kernel $KERNEL \\\n    -append \"earlyprintk=serial console=ttyS0\" \\\n    -initrd $INITRD \\\n    -nographic \\\n    -monitor pty \\\n    -monitor unix:monitor,server,nowait\n</code></pre> <p>The default password is <code>root</code>.</p>"},{"location":"developer-guide/#testing-agent-independently","title":"Testing Agent Independently","text":"<p>Agent once started will wait to receive its configuration via v-sock. For testing purposes you can use the script in <code>cocos/test/manual/agent-config</code>. This script sends agent config and also receives logs and events from agent. Once the VM is launched you can send config including computation manifest to agent as follows:</p> <pre><code>cd cocos\ngo run ./test/manual/agent-config/main.go &lt;data-path&gt; &lt;algo-path&gt; &lt;public-key-path&gt; &lt;attested-tls-bool&gt;\n</code></pre>"},{"location":"developer-guide/#testing-manager","title":"Testing Manager","text":"<p>Manager is a gRPC client and needs gRPC sever to connect to. We have an example server for testing purposes in <code>test/computations</code>. Run the server as follows:</p> <pre><code>go run ./test/computations/main.go /path/to/algo/file /path/to/public/key/file &lt;attested_tls_bool&gt; /path/to/data/file1.zip path/to/data/file2.zip path/to/data/file3.zip\n</code></pre>"},{"location":"developer-guide/#run-manager","title":"Run Manager","text":"<p>Create two directories in <code>cocos/cmd/manager</code>, the directories are <code>img</code> and <code>tmp</code>. Copy <code>rootfs.cpio.gz</code> and <code>bzImage</code> from the buildroot output directory files to <code>cocos/cmd/manager/img</code>.</p> <p>Next run manager client.</p> <pre><code>cd cmd/manager\nMANAGER_GRPC_URL=localhost:7001 \\\n    MANAGER_LOG_LEVEL=debug \\\n    MANAGER_QEMU_USE_SUDO=false \\\n    MANAGER_QEMU_ENABLE_SEV=false \\\n    MANAGER_QEMU_SEV_CBITPOS=51 \\\n    MANAGER_QEMU_OVMF_CODE_FILE=/usr/share/OVMF/OVMF_CODE.fd \\\n    MANAGER_QEMU_OVMF_VARS_FILE=/usr/share/edk2/ovmf/OVMF_VARS.fd \\\n    ./build/cocos-manager\n</code></pre> <p>This will result in manager sending a whoIam request to manager-server. Manager server will then launch a VM with agent running and having received the computation manifest.</p>"},{"location":"developer-guide/#protobuf","title":"Protobuf","text":"<p>If you've made any changes to .proto files, you should call protoc command prior to compiling individual microservices.</p> <p>To do this by hand, execute: <code>make protoc</code></p>"},{"location":"developer-guide/#mocks","title":"Mocks","text":"<p>To run tests, some of the services are mocked and these need to be updated if the function signatures are changed.</p> <p>To do this, execute: <code>make mocks</code></p>"},{"location":"developer-guide/#troubleshooting","title":"Troubleshooting","text":"<p>If you run <code>ps aux | grep qemu-system-x86_64</code> and it returns give you something like this:</p> <pre><code>sammy      13913  0.0  0.0      0     0 pts/2    Z+   20:17   0:00 [qemu-system-x86] &lt;defunct&gt;\n</code></pre> <p>means that the a QEMU virtual machine that is currently defunct, meaning that it is no longer running. More precisely, the defunct process in the output is also known as a \"zombie\" process.</p>"},{"location":"developer-guide/#kill-qemu-system-x86_64-processes","title":"Kill <code>qemu-system-x86_64</code> Processes","text":"<p>To kill any leftover <code>qemu-system-x86_64</code> processes, use <code>pkill -f qemu-system-x86_64</code> The pkill command is used to kill processes by name or by pattern. The <code>-f</code> flag to specify that we want to kill processes that match the pattern <code>qemu-system-x86_64</code>. It sends the SIGKILL signal to all processes that are running <code>qemu-system-x86_64</code>.</p> <p>If this does not work, i.e. if <code>ps aux | grep qemu-system-x86_64</code> still outputs <code>qemu-system-x86_64</code> related process(es), you can kill the unwanted process with <code>kill -9 &lt;PID&gt;</code>, which also sends a SIGKILL signal to the process.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding install the following requirements. - Golang (version 1.21.6)</p>"},{"location":"getting-started/#getting-cocos","title":"Getting CoCos","text":"<p>Get the cocos repository: <code>git clone https://github.com/ultravioletrs/cocos.git</code></p>"},{"location":"getting-started/#hal","title":"HAL","text":"<p>Get the hardware abstraction layer from the releases on the cocos repository. Two files will be required: - <code>rootfs.cpio.gz</code> - Initramfs - <code>bzImage</code> - Kernel</p> <p>Create two directories in <code>cocos/cmd/manager</code>, the directories are <code>img</code> and <code>tmp</code>. Copy the downloaded files to <code>cocos/cmd/manager/img</code>.</p>"},{"location":"getting-started/#starting-manager-server","title":"Starting Manager Server","text":"<p>Manager is a gRPC client and needs gRPC sever to connect to. We have an example server for testing purposes in <code>test/manager-server</code>. Run the server as follows:</p> <pre><code>go run ./test/computations/main.go /path/to/algo/file /path/to/public/key/file &lt;attested_tls_bool&gt; /path/to/data/file1.zip path/to/data/file2.zip path/to/data/file3.zip\n</code></pre> <p>Multiple data files can be provided, depending on the nature of the algorithm and type of data.</p> <p>The output should be simillar to this: <code>{\"time\":\"2024-03-19T12:27:46.542638146+03:00\",\"level\":\"INFO\",\"msg\":\"manager_test_server service gRPC server listening at :7001 without TLS\"}</code></p> <p>The test server uses the paths to the algorithm and datasets to obtain the file and include the file hashes to the computation manifest. The files are uploaded to agent via cli. The public key provided can be generated using openssl or cocos-cli.</p>"},{"location":"getting-started/#running-manager","title":"Running Manager","text":"<p>Next we need to start manager. But first we'll need to install some prerequisites.</p>"},{"location":"getting-started/#vsock","title":"Vsock","text":"<p>Virtio-vsock is a host/guest communications device. It allows applications in the guest and host to communicate. In this case, it is used to communicate between manager and agent. To enable it run the following on the host: <code>sudo modprobe vhost_vsock</code></p> <p>to confirm that it is enabled run: <code>ls -l /dev/vsock</code> and <code>ls -l /dev/vhost-vsock</code> the output should be simillar to this respectively: <code>crw-rw-rw- 1 root root 10, 121 Mar 18 14:01 /dev/vsock</code> and <code>crw-rw-rw- 1 root kvm 10, 241 Mar 18 14:01 /dev/vhost-vsock</code></p>"},{"location":"getting-started/#ovmf","title":"OVMF","text":"<p>Find the ovmf code file:</p> <pre><code>sudo find / -name OVMF_CODE.fd\n</code></pre> <p>The output will be simillar to this:</p> <pre><code>/usr/share/edk2/x64/OVMF_CODE.fd\n/usr/share/edk2/ia32/OVMF_CODE.fd\n</code></pre> <p>Find the ovmf vars file:</p> <pre><code>sudo find / -name OVMF_VARS.fd\n</code></pre> <p>the output will be simillar to this </p> <pre><code>/usr/share/edk2/x64/OVMF_VARS.fd\n/usr/share/edk2/ia32/OVMF_VARS.fd\n</code></pre>"},{"location":"getting-started/#run","title":"Run","text":"<p>When manager connects to the computations server, the server then sends a computation manifest. In response manager will sends logs and events from the computation both from manager and agent. To start run:</p> <pre><code>cd cmd/manager\nMANAGER_GRPC_URL=localhost:7001 \\\n    MANAGER_LOG_LEVEL=debug \\\n    MANAGER_QEMU_USE_SUDO=false \\\n    MANAGER_QEMU_ENABLE_SEV=false \\\n    MANAGER_QEMU_SEV_CBITPOS=51 \\\n    MANAGER_QEMU_OVMF_CODE_FILE=/usr/share/OVMF/OVMF_CODE.fd \\\n    MANAGER_QEMU_OVMF_VARS_FILE=/usr/share/edk2/ovmf/OVMF_VARS.fd \\\n    ./build/cocos-manager\n</code></pre> <p>The output on manager will be simillar to this:</p> <pre><code>{\"time\":\"2024-03-19T12:38:53.647541406+03:00\",\"level\":\"INFO\",\"msg\":\"/usr/bin/qemu-system-x86_64 -enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=64 -m 2048M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/edk2/x64/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=/usr/share/edk2/x64/OVMF_VARS.fd -netdev user,id=vmnic,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,addr=0x2,romfile= -device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=3 -vnc :0 -kernel img/bzImage -append \\\"earlyprintk=serial console=ttyS0\\\" -initrd img/rootfs.cpio.gz -nographic -monitor pty\"}\n{\"time\":\"2024-03-19T12:39:07.819774273+03:00\",\"level\":\"INFO\",\"msg\":\"Method Run for computation took 14.169748744s to complete\"}\n{\"time\":\"2024-03-19T12:39:07.821687259+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"Method Run for computation 1 took 51.066\u00b5s to complete without errors.\\\"  computation_id:\\\"1\\\"  level:\\\"INFO\\\"  timestamp:{seconds:1710841147  nanos:818774262}}\"}\n{\"time\":\"2024-03-19T12:39:07.821994067+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"Transition: receivingAlgorithms -&gt; receivingAlgorithms\\\\n\\\"  computation_id:\\\"1\\\"  level:\\\"DEBUG\\\"  timestamp:{seconds:1710841147  nanos:819067478}}\"}\n{\"time\":\"2024-03-19T12:39:07.822053853+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_event:{event_type:\\\"receivingAlgorithms\\\"  timestamp:{seconds:1710841147  nanos:819118886}  computation_id:\\\"1\\\"  originator:\\\"agent\\\"  status:\\\"in-progress\\\"}\"}\n{\"time\":\"2024-03-19T12:39:07.822605252+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"agent service gRPC server listening at :7002 without TLS\\\"  computation_id:\\\"1\\\"  level:\\\"INFO\\\"  timestamp:{seconds:1710841147  nanos:819759020}}\"}\n</code></pre> <p>The output on manager test server will be simillar to this:</p> <pre><code>{\"time\":\"2024-03-19T12:27:46.542638146+03:00\",\"level\":\"INFO\",\"msg\":\"manager_test_server service gRPC server listening at :7001 without TLS\"}\n{\"time\":\"2024-03-19T12:38:53.64961785+03:00\",\"level\":\"DEBUG\",\"msg\":\"received who am on ip address [::1]:48592\"}\nreceived whoamI\n&amp;{}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1710841133 nanos:649982672} computation_id:\"1\" originator:\"manager\" status:\"starting\"}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1710841133 nanos:650082447} computation_id:\"1\" originator:\"manager\" status:\"in-progress\"}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1710841147 nanos:819724344} computation_id:\"1\" originator:\"manager\" status:\"complete\"}\nreceived runRes\n&amp;{agent_port:\"46693\" computation_id:\"1\"}\nreceived agent log\n&amp;{message:\"Method Run for computation 1 took 51.066\u00b5s to complete without errors.\" computation_id:\"1\" level:\"INFO\" timestamp:{seconds:1710841147 nanos:818774262}}\nreceived agent log\n&amp;{message:\"Transition: receivingAlgorithms -&gt; receivingAlgorithms\\n\" computation_id:\"1\" level:\"DEBUG\" timestamp:{seconds:1710841147 nanos:819067478}}\nreceived agent event\n&amp;{event_type:\"receivingAlgorithms\" timestamp:{seconds:1710841147 nanos:819118886} computation_id:\"1\" originator:\"agent\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"agent service gRPC server listening at :7002 without TLS\" computation_id:\"1\" level:\"INFO\" timestamp:{seconds:1710841147 nanos:819759020}}\n</code></pre> <p>From the logs we see agent has been bound to port <code>48592</code> which we can use with agent cli to send the algorithm, datasets and retrieve results. In this case the <code>AGENT_GRPC_URL</code> will be <code>localhost:48592</code>. </p> <p>To test agent proceed to CLI, where the algorithm will be uploaded, followed by the dataset, which will be followed by result retrieval once results are ready.</p>"},{"location":"hal/","title":"Hardware Abstraction Layer (HAL)","text":"<p>HAL is a layer of programming that allows the software to interact with the hardware device at a general level rather than at the detailed hardware level. Cocos uses HAL and AMD SEV-SNP as an abstraction layer for confidential computing.</p> <p>AMD SEV-SNP creates secure virtual machines (SVMs). VMs are usually used to run an operating system (e.g., Ubuntu and its applications). To avoid using a whole OS, HAL uses:</p> <ul> <li>Linux kernel v6.6 - vmlinuz archive with the standard Linux kernel v6.6 with support for AMD SEV.</li> <li>File system - the initial RAM file system (initramfs) that is used as the root file system of the VM.</li> </ul> <p>This way, applications can be executed in the SVM, and the whole HAL SVM is entirely in RAM, protected by SEV-SNP. Being a RAM-only SVM means that secrets that are kept in the SVM will be destroyed when the SVM stops working.</p>"},{"location":"hal/#how-is-hal-constructed","title":"How is HAL constructed?","text":"<p>HAL is made using the tool Buildroot. Buildroot is used to create efficient, embedded Linux systems, and we use it to create the compressed image of the kernel (vmlinuz) and the initial file system (initramfs).</p> <p>HAL configuration for Buildroot also includes Python runtime and agent software support. You can read more about the Agent software here.</p>"},{"location":"hal/#how-does-it-work","title":"How does it work?","text":"<p>HAL is combined with AMD SEV-SNP to provide a fully encrypted VM that can be verified using remote attestation. You can read more about the attestation process here.</p> <p>Cocos uses QEMU and Open Virtual Machine Firmware (OVMF) to boot the confidential VM. During boot with SEV-SNP, the AMD Secure Processor (AMD SP) measures (calculates the hash) of the contents of the VM to insert that hash into the attestation report. This measurement is proof of what is currently running inside the VM. The problem with SEV is that it only measures the Open Virtual Machine Firmware (OVMF). To solve this, we have built OVMF so that OVMF contains hashes of the vmlinuz and initrams. Once the OVMF is loaded, it will load the vmlinuz and initramfs into memory, but it will continue the boot process only if the hashes of the vmlinuz and initramfs match the hashes stored in OVMF. This way, the attestation report will contain the measurement of OVMF, with the hashes, and OVMF will guarantee that the correct kernel and file system are booted. The whole process can be seen in the following diagram. The green color represents the trusted part of the system, while the red is untrusted:</p> <p></p> <p>This process guarantees that the whole VM is secure and can be verified. </p> <p>After the kernel boots, the agent is started and ready for work.</p>"},{"location":"manager/","title":"Manager","text":"<p>Manager runs on the TEE-capable host (AMD SEV-SNP, Intel SGX or Intel TDX) and has 2 main roles:</p> <ol> <li>To deploy the well-prepared TEE upon the <code>start</code> command and upload the necessary configuration into it (command line arguments, TLS certificates, etc...)</li> <li>To monitor deployed TEE and provide remot logs</li> </ol> <p>Manager expsoses and API for control, based on gRPC, and is controlled by Computation Management service. Manager acts as the client of Computation Management service and connects to it upon the start via TLS-encoded gRPC connection.</p> <p>Computation Management service is used to to cnfigure computation metadata. Once a computation is created by a user and the invited users have uploaded their public certificates (used later for identification and data exchange in the enclave), a run request is sent. The Manager is responsible for creating the TEE in which computation will be ran and managing the computation lifecycle.</p> <p>Communication to between Computation Management cloud and the Manager is done via gRPC, while communication between Manager and Agent is done via Virtio Vsock. Vsock is used to send Agent events from the computation in the Agent to the Manager. The Manager then sends the events back to Computation Mangement cloud via gRPC, and these are visible to the end user.</p> <p>The picture below shows where the Manager runs in the Cocos system, helping us better understand its role.</p> <p></p>"},{"location":"manager/#manager-agent","title":"Manager &lt;&gt; Agent","text":"<p>When TEE is booted, and Agent is autmatically deployed and is used for outside communication with the enclave (via the API) and for computation orchestration (data and algorithm upload, start of the computation and retrieval of the result).</p> <p>Agent is a gRPC server, and CLI is a gRPC client of the Agent. The Manager sends the Computation Manifest to the Agent via vsock and the Agent runs the computation, according to the Computation Manifest, while sending evnets back to manager on the status. The Manager then sends the events it receives from agent via vsock to Computation Mangement cloud through gRPC.</p>"},{"location":"manager/#setup-and-test-manager-agent","title":"Setup and Test Manager &lt;&gt; Agent","text":"<pre><code>git clone https://github.com/ultravioletrs/cocos\ncd cocos\n</code></pre> <p>N.B. All relative paths in this document are relative to <code>cocos</code> repository directory.</p>"},{"location":"manager/#qemu-kvm","title":"QEMU-KVM","text":"<p>QEMU-KVM is a virtualization platform that allows you to run multiple operating systems on the same physical machine. It is a combination of two technologies: QEMU and KVM.</p> <ul> <li>QEMU is an emulator that can run a variety of operating systems, including Linux, Windows, and macOS.</li> <li>KVM is a Linux kernel module that allows QEMU to run virtual machines.</li> </ul> <p>To install QEMU-KVM on a Debian based machine, run</p> <pre><code>sudo apt update\nsudo apt install qemu-kvm\n</code></pre> <p>Create <code>img</code> directory in <code>cmd/manager</code>. Create <code>tmp</code> directory in <code>cmd/manager</code>.</p>"},{"location":"manager/#add-v-sock","title":"Add V-sock","text":"<p>The necessary kernel modules must be loaded on the hypervisor.</p> <pre><code>sudo modprobe vhost_vsock\nls -l /dev/vhost-vsock\n# crw-rw-rw- 1 root kvm 10, 241 Jan 16 12:05 /dev/vhost-vsock\nls -l /dev/vsock\n# crw-rw-rw- 1 root root 10, 121 Jan 16 12:05 /dev/vsock\n</code></pre>"},{"location":"manager/#prepare-cocos-hal","title":"Prepare Cocos HAL","text":"<p>Cocos HAL for Linux is framework for building custom in-enclave Linux distribution. Use the instructions in Readme. Once the image is built copy the kernel and rootfs image to <code>cmd/manager/img</code> from <code>buildroot/output/images/bzImage</code> and <code>buildroot/output/images/rootfs.cpio.gz</code> respectively.</p>"},{"location":"manager/#test-vm-creation","title":"Test VM Creation","text":"<pre><code>cd cmd/manager\n\nsudo find / -name OVMF_CODE.fd\n# =&gt; /usr/share/OVMF/OVMF_CODE.fd\nOVMF_CODE=/usr/share/OVMF/OVMF_CODE.fd\n\nsudo find / -name OVMF_VARS.fd\n# =&gt; /usr/share/OVMF/OVMF_VARS.fd\nOVMF_VARS=/usr/share/OVMF/OVMF_VARS.fd\n\nKERNEL=\"img/bzImage\"\nINITRD=\"img/rootfs.cpio.gz\"\n\nqemu-system-x86_64 \\\n    -enable-kvm \\\n    -cpu EPYC-v4 \\\n    -machine q35 \\\n    -smp 4 \\\n    -m 2048M,slots=5,maxmem=10240M \\\n    -no-reboot \\\n    -drive if=pflash,format=raw,unit=0,file=$OVMF_CODE,readonly=on \\\n    -netdev user,id=vmnic,hostfwd=tcp::7020-:7002 \\\n    -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,romfile= \\\n    -device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=3 -vnc :0 \\\n    -kernel $KERNEL \\\n    -append \"earlyprintk=serial console=ttyS0\" \\\n    -initrd $INITRD \\\n    -nographic \\\n    -monitor pty \\\n    -monitor unix:monitor,server,nowait\n</code></pre> <p>Once the VM is booted press enter and on the login use username <code>root</code>.</p>"},{"location":"manager/#build-and-run-agent","title":"Build and Run Agent","text":"<p>Agent is started automatically in the VM.</p> <pre><code># List running processes and use 'grep' to filter for processes containing 'agent' in their names.\nps aux | grep cocos-agent\n# This command helps verify that the 'agent' process is running.\n# The output shows the process ID (PID), resource usage, and other information about the 'cocos-agent' process.\n# For example: 118 root     cocos-agent\n</code></pre> <p>We can also check if <code>Agent</code> is reachable from the host machine:</p> <pre><code># Use netcat (nc) to test the connection to localhost on port 7020.\nnc -zv localhost 7020\n# Output:\n# nc: connect to localhost (::1) port 7020 (tcp) failed: Connection refused\n# Connection to localhost (127.0.0.1) 7020 port [tcp/*] succeeded!\n</code></pre>"},{"location":"manager/#conclusion","title":"Conclusion","text":"<p>Now you are able to use <code>Manager</code> with <code>Agent</code>. Namely, <code>Manager</code> will create a VM with a separate OVMF variables file on manager <code>/run</code> request.</p>"},{"location":"manager/#ovmf","title":"OVMF","text":"<p>We need Open Virtual Machine Firmware. OVMF is a port of Intel's tianocore firmware - an open source implementation of the Unified Extensible Firmware Interface (UEFI) - used by a qemu virtual machine. We need OVMF in order to run virtual machine with focal-server-cloudimg-amd64. When we install QEMU, we get two files that we need to start a VM: <code>OVMF_VARS.fd</code> and <code>OVMF_CODE.fd</code>. We will make a local copy of <code>OVMF_VARS.fd</code> since a VM will modify this file. On the other hand, <code>OVMF_CODE.fd</code> is only used as a reference, so we only record its path in an environment variable.</p> <pre><code>sudo find / -name OVMF_CODE.fd\n# =&gt; /usr/share/OVMF/OVMF_CODE.fd\nMANAGER_QEMU_OVMF_CODE_FILE=/usr/share/OVMF/OVMF_CODE.fd\n\nsudo find / -name OVMF_VARS.fd\n# =&gt; /usr/share/OVMF/OVMF_VARS.fd\nMANAGER_QEMU_OVMF_VARS_FILE=/usr/share/OVMF/OVMF_VARS.fd\n</code></pre> <p>NB: we set environment variables that we will use in the shell process where we run <code>manager</code>.</p>"},{"location":"manager/#deployment","title":"Deployment","text":"<p>To start the service, execute the following shell script (note a server needs to be running see  here):</p> <pre><code># download the latest version of the service\ngo get github.com/ultravioletrs/cocos\n\ncd $GOPATH/src/github.com/ultravioletrs/cocos\n\n# compile the manager\nmake manager\n\n# copy binary to bin\nmake install\n\n# set the environment variables and run the service\nMANAGER_GRPC_URL=localhost:7001\nMANAGER_LOG_LEVEL=debug \\\nMANAGER_QEMU_USE_SUDO=false \\\nMANAGER_QEMU_ENABLE_SEV=false \\\n./build/cocos-manager\n</code></pre> <p>To enable AMD SEV support, start manager like this </p> <pre><code>MANAGER_GRPC_URL=localhost:7001\nMANAGER_LOG_LEVEL=debug \\\nMANAGER_QEMU_USE_SUDO=true \\\nMANAGER_QEMU_ENABLE_SEV=true \\\nMANAGER_QEMU_SEV_CBITPOS=51 \\\n./build/cocos-manager\n</code></pre>"},{"location":"manager/#verifying-vm-launch","title":"Verifying VM Launch","text":"<p>NB: To verify that the manager successfully launched the VM, you need to open three terminals on the same machine. In one terminal, you need to launch the computations server by executing (with the environment variables of choice):</p> <pre><code>go run ./test/computations/main.go &lt;path to dataset&gt; &lt;path to algorithm&gt;\n</code></pre> <p>and in the second the manager by executing (with the environment variables of choice):</p> <pre><code>go run ./cmd/manager/main.go\n</code></pre> <p>Ensure that the Manager can connect to the computations server by setting the MANAGER_GRPC_PORT with the port value of the computations server. In the last terminal window, you can run the verification commands.</p> <p>To verify that the manager launched the VM successfully, run the following command:</p> <pre><code>ps aux | grep qemu-system-x86_64\n</code></pre> <p>You should get something similar to this</p> <pre><code>darko     324763 95.3  6.0 6398136 981044 ?      Sl   16:17   0:15 /usr/bin/qemu-system-x86_64 -enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=64 -m 4096M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/OVMF/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=img/OVMF_VARS.fd -device virtio-scsi-pci,id=scsi,disable-legacy=on,iommu_platform=true -drive file=img/focal-server-cloudimg-amd64.img,if=none,id=disk0,format=qcow2 -device scsi-hd,drive=disk0 -netdev user,id=vmnic,hostfwd=tcp::2222-:22,hostfwd=tcp::9301-:9031,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,romfile= -nographic -monitor pty\n</code></pre> <p>If you run a command as <code>sudo</code>, you should get the output similar to this one</p> <pre><code>root       37982  0.0  0.0   9444  4572 pts/0    S+   16:18   0:00 sudo /usr/local/bin/qemu-system-x86_64 -enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=64 -m 4096M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/OVMF/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=img/OVMF_VARS.fd -device virtio-scsi-pci,id=scsi,disable-legacy=on,iommu_platform=true -drive file=img/focal-server-cloudimg-amd64.img,if=none,id=disk0,format=qcow2 -device scsi-hd,drive=disk0 -netdev user,id=vmnic,hostfwd=tcp::2222-:22,hostfwd=tcp::9301-:9031,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,romfile= -object sev-guest,id=sev0,cbitpos=51,reduced-phys-bits=1 -machine memory-encryption=sev0 -nographic -monitor pty\nroot       37989  122 13.1 5345816 4252312 pts/0 Sl+  16:19   0:04 /usr/local/bin/qemu-system-x86_64 -enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=64 -m 4096M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/OVMF/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=img/OVMF_VARS.fd -device virtio-scsi-pci,id=scsi,disable-legacy=on,iommu_platform=true -drive file=img/focal-server-cloudimg-amd64.img,if=none,id=disk0,format=qcow2 -device scsi-hd,drive=disk0 -netdev user,id=vmnic,hostfwd=tcp::2222-:22,hostfwd=tcp::9301-:9031,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,romfile= -object sev-guest,id=sev0,cbitpos=51,reduced-phys-bits=1 -machine memory-encryption=sev0 -nographic -monitor pty\n</code></pre> <p>The two processes are due to the fact that we run the command <code>/usr/bin/qemu-system-x86_64</code> as <code>sudo</code>, so there is one process for <code>sudo</code> command and the other for <code>/usr/bin/qemu-system-x86_64</code>.</p>"},{"location":"manager/#troubleshooting","title":"Troubleshooting","text":"<p>If the <code>ps aux | grep qemu-system-x86_64</code> give you something like this</p> <pre><code>darko      13913  0.0  0.0      0     0 pts/2    Z+   20:17   0:00 [qemu-system-x86] &lt;defunct&gt;\n</code></pre> <p>means that the a QEMU virtual machine that is currently defunct, meaning that it is no longer running. More precisely, the defunct process in the output is also known as a \"zombie\" process.</p> <p>You can troubleshoot the VM launch procedure by running directly <code>qemu-system-x86_64</code> command. When you run <code>manager</code> with <code>MANAGER_LOG_LEVEL=info</code> env var set, it prints out the entire command used to launch a VM. The relevant part of the log might look like this</p> <pre><code>{\"level\":\"info\",\"message\":\"/usr/bin/qemu-system-x86_64 -enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=64 -m 4096M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/OVMF/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=img/OVMF_VARS.fd -device virtio-scsi-pci,id=scsi,disable-legacy=on,iommu_platform=true -drive file=img/focal-server-cloudimg-amd64.img,if=none,id=disk0,format=qcow2 -device scsi-hd,drive=disk0 -netdev user,id=vmnic,hostfwd=tcp::2222-:22,hostfwd=tcp::9301-:9031,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,romfile= -nographic -monitor pty\",\"ts\":\"2023-08-14T18:29:19.2653908Z\"}\n</code></pre> <p>You can run the command - the value of the <code>\"message\"</code> key - directly in the terminal:</p> <pre><code>/usr/bin/qemu-system-x86_64 -enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=64 -m 4096M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/OVMF/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=img/OVMF_VARS.fd -device virtio-scsi-pci,id=scsi,disable-legacy=on,iommu_platform=true -drive file=img/focal-server-cloudimg-amd64.img,if=none,id=disk0,format=qcow2 -device scsi-hd,drive=disk0 -netdev user,id=vmnic,hostfwd=tcp::2222-:22,hostfwd=tcp::9301-:9031,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,romfile= -nographic -monitor pty\n</code></pre> <p>and look for the possible problems. This problems can usually be solved by using the adequate env var assignments. Look in the <code>manager/qemu/config.go</code> file to see the recognized env vars. Don't forget to prepend <code>MANAGER_QEMU_</code> to the name of the env vars.</p>"},{"location":"manager/#kill-qemu-system-x86_64-processes","title":"Kill <code>qemu-system-x86_64</code> Processes","text":"<p>To kill any leftover <code>qemu-system-x86_64</code> processes, use</p> <pre><code>pkill -f qemu-system-x86_64\n</code></pre> <p>The pkill command is used to kill processes by name or by pattern. The -f flag to specify that we want to kill processes that match the pattern <code>qemu-system-x86_64</code>. It sends the SIGKILL signal to all processes that are running <code>qemu-system-x86_64</code>.</p> <p>If this does not work, i.e. if <code>ps aux | grep qemu-system-x86_64</code> still outputs <code>qemu-system-x86_64</code> related process(es), you can kill the unwanted process with <code>kill -9 &lt;PID&gt;</code>, which also sends a SIGKILL signal to the process.</p>"},{"location":"tee/","title":"TEE","text":"<p>A trusted execution environment (TEE) is a separate part of the main memory and the CPU that encrypts code/data and enables \"on the fly\" executions of the said encrypted code/data. One of the examples of TEEs is Intel Secure Guard Extensions (SGX) and AMD Secure Encrypted Virtualization (SEV).</p>"},{"location":"tee/#amd-sev","title":"AMD SEV","text":"<p>AMD SEV and its latest and most secure iteration, AMD Secure Encrypted Virtualization - Secure Nested Paging (SEV-SNP), is the AMD technology that isolates entire virtual machines (VMs). SEV-SNP encrypts the whole VM and provides confidentiality and integrity protection of the VM memory. This way, the hypervisor or any other application on the host machine cannot read the VM memory.</p> <p>In CocosAI, we use an in-memory VM image called the Hardware Abstraction Layer (HAL). You can read more on HAL here.</p> <p>One of the critical components of the SEV technology is the remote attestation. Remote attestation is a process in which one side (the attester) collects information about itself and sends that information to the client (or the relying party) for the relying party to assess the trustworthiness of the attester. If the attester is deemed trustworthy, the relying party will send confidential code/data or any secrets to the attester. You can read more on the attestation process here.</p>"}]}